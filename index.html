<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Tirage Golf</title>
  <style>
    body { font-family: -apple-system, system-ui, Segoe UI, Roboto, Arial, sans-serif; margin: 20px; max-width: 1040px; }
    h1 { margin: 0 0 8px; }
    .sub { color: #555; margin-bottom: 18px; }
    .grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); gap: 10px; }
    .card { border: 1px solid #ddd; border-radius: 12px; padding: 12px; }
    .controls { display: flex; flex-wrap: wrap; gap: 10px; margin: 12px 0 16px; }
    button { padding: 10px 12px; border-radius: 10px; border: 1px solid #ccc; background: #f6f6f6; cursor: pointer; }
    button.primary { background: #111; color: #fff; border-color: #111; }
    button:active { transform: translateY(1px); }
    textarea { width: 100%; min-height: 150px; border-radius: 10px; border: 1px solid #ddd; padding: 10px; }
    select, input[type="time"] { padding: 8px 10px; border-radius: 10px; border: 1px solid #ddd; background: #fff; }
    .pill { display: inline-block; padding: 2px 10px; border: 1px solid #ddd; border-radius: 999px; font-size: 12px; color: #444; }
    .warn { color: #9a4b00; }
    .ok { color: #0a6b2f; }
    .row { display: flex; gap: 12px; align-items: center; flex-wrap: wrap; }
    .small { font-size: 12px; color: #666; }
    .group { margin: 8px 0; }
    .sectionTitle { font-weight: 700; margin: 4px 0 10px; }
    .muted { color:#666; }
    .divider { height:1px; background:#eee; margin:12px 0; }
    label.inline { display:flex; gap:8px; align-items:center; }
    .field { display:flex; gap:8px; align-items:center; }
  </style>
</head>
<body>
  <h1>Tirage Golf</h1>
  <div class="sub">
    Coche les présents → Générer. Règle fixe : <strong>groupes de 3 d’abord</strong>, puis <strong>groupes de 4 à la fin</strong>.
  </div>

  <div class="card">
    <div class="row">
      <span class="pill" id="countPill">0 présents</span>
      <span class="small">Les coches et l’horaire sont mémorisés sur ce Mac.</span>
    </div>

    <div class="controls">
      <button class="primary" id="btnGenerate">Générer</button>
      <button id="btnRegenerate">Regénérer (nouvel aléa)</button>
      <button id="btnAllPlayers">Tout cocher (joueurs)</button>
      <button id="btnNoneAll">Tout décocher</button>
      <button id="btnCopy">Copier pour WhatsApp</button>

      <span class="field small" style="margin-left:auto;">
        <strong>1er départ</strong>
        <input type="time" id="startTime" />
        <span class="muted">(puis +8 min)</span>
      </span>
    </div>

    <div class="card" style="margin-top:12px;">
      <div class="sectionTitle">Options (facultatives)</div>
      <div class="row">
        <span class="small"><strong>Forcer une paire</strong> :</span>
        <select id="pairA"></select>
        <select id="pairB"></select>

        <label class="inline small">
          <input type="checkbox" id="pairLast" />
          Mettre la paire dans la <strong>dernière partie</strong> (tout en gardant les plus nombreux à la fin)
        </label>

        <button id="btnClearPair">Désactiver</button>
      </div>
      <div class="small muted" style="margin-top:6px;">
        Si “dernière partie” est coché : la paire ira dans le <strong>dernier groupe de 4</strong> s’il y en a, sinon dans le <strong>dernier groupe de 3</strong>.
      </div>
    </div>

    <div class="divider"></div>

    <div class="sectionTitle">Joueurs</div>
    <div class="grid" id="playersGrid"></div>

    <div class="sectionTitle" style="margin-top:16px;">Invités</div>
    <div class="grid" id="guestsGrid"></div>
  </div>

  <div class="card" style="margin-top: 14px;">
    <div class="row" style="justify-content: space-between;">
      <strong>Résultat</strong>
      <span id="status" class="small"></span>
    </div>
    <div id="result"></div>

    <div style="margin-top: 10px;">
      <strong>Texte WhatsApp</strong>
      <textarea id="waText" readonly></textarea>
    </div>
  </div>

<script>
  // === 1) Liste fixe des 20 joueurs ===
  const players = [
    "RG","AT","GDG","GG","PZ","BD","NH","TLT","JD","CG",
    "JMP","JPG","AP","TM","HDS","AC","TB","SL","TBU","JLH"
  ];

  // === 2) Invités ===
  const guests = ["INV1","INV2","INV3"];

  const STORAGE_KEY = "tirage_golf_presence_v4";
  const PAIR_KEY = "tirage_golf_pair_v2";
  const TIME_KEY = "tirage_golf_start_time_v1";
  const INTERVAL_MIN = 8;

  function loadJSON(key, fallback) {
    try {
      const raw = localStorage.getItem(key);
      if (!raw) return fallback;
      return JSON.parse(raw);
    } catch { return fallback; }
  }
  function saveJSON(key, obj) {
    localStorage.setItem(key, JSON.stringify(obj));
  }

  // Fisher–Yates shuffle
  function shuffle(arr) {
    const a = arr.slice();
    for (let i = a.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [a[i], a[j]] = [a[j], a[i]];
    }
    return a;
  }

  // Groupes 3/4 uniquement, et ordre [3...,4...] => 4 à la fin
  function groupSizes(n) {
    if (n < 3) throw new Error("Il faut au moins 3 joueurs présents.");

    const r = n % 4;
    let n3 = 0, n4 = 0;

    if (r === 0) { n3 = 0; n4 = n / 4; }
    else if (r === 1) {
      if (n < 9) throw new Error(`Impossible de faire uniquement des groupes de 3/4 avec ${n} joueurs.`);
      n3 = 3; n4 = (n - 9) / 4;
    } else if (r === 2) {
      if (n < 6) throw new Error(`Impossible de faire uniquement des groupes de 3/4 avec ${n} joueurs.`);
      n3 = 2; n4 = (n - 6) / 4;
    } else { // r === 3
      n3 = 1; n4 = (n - 3) / 4;
    }

    return [...Array(n3).fill(3), ...Array(n4).fill(4)];
  }

  function getForcedPairOption() {
    const a = document.getElementById("pairA")?.value || "";
    const b = document.getElementById("pairB")?.value || "";
    const last = document.getElementById("pairLast")?.checked || false;
    if (!a || !b || a === b) return null;
    return { a, b, last };
  }

  // Règle paire + respect strict "plus nombreux à la fin"
  function makeGroups(presentList, forcedPair) {
    const n = presentList.length;
    const sizes = groupSizes(n);

    let pool = shuffle(presentList);

    // Pair applicable ?
    let pair = null;
    if (forcedPair && pool.includes(forcedPair.a) && pool.includes(forcedPair.b)) {
      pair = forcedPair;
      pool = pool.filter(x => x !== pair.a && x !== pair.b);
    }

    // Si paire, on choisit taille cible : 4 si on a des 4, sinon 3
    let targetSize = null;
    if (pair) targetSize = sizes.includes(4) ? 4 : 3;

    // Index cible :
    // - last=true => dernier groupe de taille targetSize (donc dernier 4 si existe, sinon dernier 3)
    // - last=false => premier groupe de taille targetSize
    let targetIndex = -1;
    if (pair) {
      if (pair.last) {
        for (let i = sizes.length - 1; i >= 0; i--) {
          if (sizes[i] === targetSize) { targetIndex = i; break; }
        }
      } else {
        for (let i = 0; i < sizes.length; i++) {
          if (sizes[i] === targetSize) { targetIndex = i; break; }
        }
      }
      if (targetIndex === -1) throw new Error("Impossible de placer la paire (aucun groupe compatible).");
    }

    const groups = [];
    for (let i = 0; i < sizes.length; i++) {
      const sz = sizes[i];

      if (pair && i === targetIndex) {
        const g = [pair.a, pair.b];
        while (g.length < sz) {
          const next = pool.shift();
          if (!next) throw new Error("Impossible de compléter le groupe forcé (pas assez de joueurs).");
          g.push(next);
        }
        groups.push(g);
      } else {
        const g = [];
        while (g.length < sz) {
          const next = pool.shift();
          if (!next) throw new Error("Erreur interne : pas assez de joueurs pour compléter un groupe.");
          g.push(next);
        }
        groups.push(g);
      }
    }

    return groups;
  }

  // === Gestion des horaires ===
  function parseTimeHHMM(s) {
    // s attendu: "HH:MM"
    if (!s || typeof s !== "string") return null;
    const m = s.match(/^(\d{2}):(\d{2})$/);
    if (!m) return null;
    const hh = Number(m[1]), mm = Number(m[2]);
    if (hh < 0 || hh > 23 || mm < 0 || mm > 59) return null;
    return { hh, mm };
  }

  function addMinutes(t, minutesToAdd) {
    const total = (t.hh * 60 + t.mm + minutesToAdd) % (24 * 60);
    const hh = Math.floor(total / 60);
    const mm = total % 60;
    return { hh, mm };
  }

  function formatHHMM(t) {
    const hh = String(t.hh).padStart(2, "0");
    const mm = String(t.mm).padStart(2, "0");
    return `${hh}:${mm}`;
  }

  function buildTeeTimes(startHHMM, count, intervalMin) {
    const start = parseTimeHHMM(startHHMM);
    if (!start) return null;
    const times = [];
    for (let i = 0; i < count; i++) {
      times.push(formatHHMM(addMinutes(start, i * intervalMin)));
    }
    return times;
  }

  // WhatsApp : horaires + liste joueurs, sans G1, sans taille, sans en-têtes
  function formatWA(groups, startTimeHHMM) {
    const times = buildTeeTimes(startTimeHHMM, groups.length, INTERVAL_MIN);
    if (!times) throw new Error("Renseigne un 1er départ valide (format HH:MM).");

    const lines = [];
    groups.forEach((g, i) => {
      lines.push(`${times[i]} : ${g.join(" / ")}`);
    });
    return lines.join("\n");
  }

  // === UI ===
  const playersGrid = document.getElementById("playersGrid");
  const guestsGrid = document.getElementById("guestsGrid");
  const countPill = document.getElementById("countPill");
  const status = document.getElementById("status");
  const result = document.getElementById("result");
  const waText = document.getElementById("waText");
  const startTimeInput = document.getElementById("startTime");

  let presence = loadJSON(STORAGE_KEY, {});

  function savePresence() {
    saveJSON(STORAGE_KEY, presence);
  }

  function renderGrid(names, container, prefix) {
    container.innerHTML = "";
    names.forEach(name => {
      const key = `${prefix}:${name}`;
      const id = `${prefix}_` + name.replace(/\s+/g, "_");
      const div = document.createElement("div");
      div.className = "card";
      div.innerHTML = `
        <label style="display:flex; gap:10px; align-items:center;">
          <input type="checkbox" id="${id}" ${presence[key] ? "checked" : ""} />
          <span>${name}</span>
        </label>
      `;
      container.appendChild(div);

      div.querySelector("input").addEventListener("change", (e) => {
        presence[key] = e.target.checked;
        savePresence();
        updateCount();
      });
    });
  }

  function getPresentList() {
    const presentPlayers = players.filter(p => presence[`P:${p}`]);
    const presentGuests  = guests.filter(g => presence[`G:${g}`]);
    return [...presentPlayers, ...presentGuests];
  }

  function updateCount() {
    const n = getPresentList().length;
    countPill.textContent = `${n} présents`;
    countPill.className = "pill " + (n >= 3 ? "ok" : "warn");
  }

  function renderResult(groups, startTimeHHMM) {
    result.innerHTML = "";

    const times = buildTeeTimes(startTimeHHMM, groups.length, INTERVAL_MIN);
    groups.forEach((g, i) => {
      const div = document.createElement("div");
      div.className = "group";
      const label = times ? times[i] : `Départ ${i+1}`;
      div.innerHTML = `<strong>${label}</strong> : ${g.join(" / ")}`;
      result.appendChild(div);
    });
  }

  function fillPairSelectors() {
    const all = [...players, ...guests];
    const selA = document.getElementById("pairA");
    const selB = document.getElementById("pairB");
    if (!selA || !selB) return;

    const opts = ["(aucun)", ...all];
    const html = opts.map(v => `<option value="${v === "(aucun)" ? "" : v}">${v}</option>`).join("");
    selA.innerHTML = html;
    selB.innerHTML = html;

    const saved = loadJSON(PAIR_KEY, { a:"", b:"", last:false });
    if (saved.a) selA.value = saved.a;
    if (saved.b) selB.value = saved.b;
    document.getElementById("pairLast").checked = !!saved.last;
  }

  function persistPairOption() {
    const forcedPair = getForcedPairOption();
    saveJSON(PAIR_KEY, forcedPair ? forcedPair : { a:"", b:"", last:false });
  }

  function loadStartTime() {
    const saved = localStorage.getItem(TIME_KEY);
    if (saved) startTimeInput.value = saved;
    else startTimeInput.value = "08:00"; // défaut raisonnable
  }

  function persistStartTime() {
    if (startTimeInput.value) localStorage.setItem(TIME_KEY, startTimeInput.value);
  }

  function generate() {
    try {
      const presentList = getPresentList();
      const forcedPair = getForcedPairOption();
      persistPairOption();
      persistStartTime();

      const groups = makeGroups(presentList, forcedPair);

      // Affichage résultat (avec horaires si possible)
      renderResult(groups, startTimeInput.value);

      // WhatsApp avec horaires uniquement
      waText.value = formatWA(groups, startTimeInput.value);

      status.textContent = "OK";
      status.className = "small ok";
    } catch (e) {
      result.innerHTML = "";
      waText.value = "";
      status.textContent = e.message;
      status.className = "small warn";
    }
  }

  // Boutons
  document.getElementById("btnGenerate").addEventListener("click", generate);
  document.getElementById("btnRegenerate").addEventListener("click", generate);

  document.getElementById("btnAllPlayers").addEventListener("click", () => {
    players.forEach(p => presence[`P:${p}`] = true);
    savePresence();
    renderAll();
  });

  document.getElementById("btnNoneAll").addEventListener("click", () => {
    [...players.map(p=>`P:${p}`), ...guests.map(g=>`G:${g}`)].forEach(k => presence[k] = false);
    savePresence();
    renderAll();
  });

  document.getElementById("btnCopy").addEventListener("click", async () => {
    if (!waText.value) return;
    try {
      await navigator.clipboard.writeText(waText.value);
      status.textContent = "Copié dans le presse-papiers";
      status.className = "small ok";
    } catch {
      status.textContent = "Copie impossible. Sélectionne le texte et copie manuellement.";
      status.className = "small warn";
    }
  });

  document.getElementById("btnClearPair").addEventListener("click", () => {
    document.getElementById("pairA").value = "";
    document.getElementById("pairB").value = "";
    document.getElementById("pairLast").checked = false;
    saveJSON(PAIR_KEY, {a:"", b:"", last:false});
  });

  document.getElementById("pairA").addEventListener("change", persistPairOption);
  document.getElementById("pairB").addEventListener("change", persistPairOption);
  document.getElementById("pairLast").addEventListener("change", persistPairOption);

  startTimeInput.addEventListener("change", () => {
    persistStartTime();
    // pas de régénération automatique, mais l'utilisateur peut le faire
  });

  function renderAll() {
    renderGrid(players, playersGrid, "P");
    renderGrid(guests, guestsGrid, "G");
    updateCount();
  }

  // Init
  fillPairSelectors();
  loadStartTime();
  renderAll();
</script>
</body>
</html>
